{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Start here","text":""},{"location":"#what-ctfs-are-about","title":"What CTFs are about","text":"<p>In the context of cybersecurity, a CTF, short for \"Capture the flag\", is a type of challenge, where the goal is to find a hidden string of characters, the flag.</p> <p>In order to get the flag, the player usually has to break or hack into systems and do things a usual user is not supposed to be able to do.</p> <p>Common examples of CTF challenges are</p> <ul> <li>getting into admin-panels of websites you are not supposed to access (cf. WEB SECURITY)</li> <li>decrypting secret messages you are not supposed to be able to read. (cf. CRYPTOGRAPHY)</li> <li>corrupting programs to do things they are not intended to do. (cf. BINARY EXPLOITATION)</li> </ul> <p>CTFs can also be about finding out what exactly a program is doing or what has happened on a specific system. This includes:</p> <ul> <li>Examining and reverse engineering binary programs or mobile applications. (cf. REVERSE ENGINEERING)</li> <li>Solving a digital forensics case. (cf. DIGITAL FORENSICS)</li> <li>Analyzing network traffic to discover vulnerabilities in protocols (cf. NETWORK ANALYSIS)</li> </ul> <p>Less common, but still present, are challenges like</p> <ul> <li>Getting secret information from a microcontroller using side-channel analysis (cf. HARDWARE SECURITY)</li> <li>gathering information about a fictional target using publicly available sources like social media (cf. OSINT)</li> </ul>"},{"location":"binary-exploitation/introduction/","title":"Introduction","text":"<p>todo</p>"},{"location":"cryptography/introduction/","title":"Introduction","text":""},{"location":"cryptography/introduction/#what-to-expect","title":"What to expect","text":"<p>Cryptography is all about encrypting messages securely. Sometimes, these encryptions are not done securely. The goal of the challenges in this category is to find a vulnerability in the cryptographic function that is being used and decrypt the secret message (the flag).</p>"},{"location":"cryptography/introduction/#types-of-challenges-not-an-exhaustive-list","title":"Types of challenges (not an exhaustive list)","text":"<ul> <li>Cracking classic cryptography like transposition ciphers or substitution ciphers</li> <li>Cracking modern ciphers (like RSA or AES) that have an unsecure configuration</li> <li>Cracking an unsecure random number generator</li> </ul>"},{"location":"cryptography/introduction/#skills-required-or-motivation-to-learn","title":"Skills required (or Motivation to learn)","text":"<ul> <li>Recognizing classic ciphers</li> <li>Willing to learn mathematical concepts around modern cryptography</li> </ul>"},{"location":"cryptography/ressources/","title":"Ressources","text":""},{"location":"cryptography/ressources/#educational","title":"Educational","text":""},{"location":"cryptography/ressources/#learning-platforms","title":"Learning platforms","text":"<ul> <li>CRYPTOHACK: Has courses and challenges on breaking modern cryptography.</li> <li>Cryptopals: Has a set of challenges that introduce to coding and breaking modern cryptography.</li> <li>PicoCTF Leaning Guide</li> </ul>"},{"location":"cryptography/ressources/#other","title":"Other","text":"<ul> <li>Crypto museum: Has interesting info on the historic use of cryptography</li> </ul>"},{"location":"cryptography/ressources/#beginner-challenges","title":"Beginner challenges","text":"<ul> <li>PicoCTF</li> </ul>"},{"location":"cryptography/ressources/#tools","title":"Tools","text":""},{"location":"cryptography/ressources/#essentials","title":"Essentials","text":"<ul> <li>Code editor to look at the cryptographic implementation.</li> <li>Online solver tools like cyberchef and dcode.fr</li> </ul>"},{"location":"cryptography/ressources/#situational","title":"Situational","text":"<ul> <li>Sagemath: Sometimes modern crypto challenges are programmed in sage.</li> </ul>"},{"location":"digital-forensics/introduction/","title":"Introduction","text":"<p>todo</p>"},{"location":"hardware-security/introduction/","title":"Introduction","text":"<p>todo</p>"},{"location":"network-analysis/introduction/","title":"Introduction","text":"<p>todo</p>"},{"location":"osint/introduction/","title":"Introduction","text":"<p>todo</p>"},{"location":"pwn/introduction/","title":"Introduction","text":"<p>The term to pwn [/po\u028an/] originally comes from the gaming community and means the verb to own. In cybersecurity, it refers to gaining unauthorized control over a system or exploiting it.</p>"},{"location":"pwn/introduction/#what-to-expect","title":"What to expect","text":"<p>In the pwn category, the user is provided a copy of a program that runs on a remote server. The user has to find a vulnerability in said program and exploit it to gain control of the remote server and to read the contents of files there. The flag is normally written in the file <code>/flag.txt</code> on the remote server.</p>"},{"location":"pwn/introduction/#skills-required-or-motivation-to-learn","title":"Skills required (or Motivation to learn)","text":"<ul> <li>C (understanding code, not necessarily writing)</li> <li>assembly (understanding, not writing)</li> <li>Memory layout of a program</li> <li>Writing Shellcode</li> </ul>"},{"location":"pwn/introduction/#types-of-challenges-not-an-exhaustive-list","title":"Types of challenges (not an exhaustive list)","text":"<ul> <li>Exploit Buffer Overflows</li> <li>Find Memory Leaks in a Binary Program</li> <li>Programs that use unsecure Libraries</li> <li>Return Oriented Programming</li> </ul>"},{"location":"pwn/ressources/","title":"Ressources","text":""},{"location":"pwn/ressources/#educational","title":"Educational","text":""},{"location":"pwn/ressources/#learning-platforms","title":"Learning platforms","text":"<ul> <li>pwn.college: Lectures and challenges about pwn from beginner to expert</li> <li>pwnable.kr Handbook: A first introduction to system exploitation</li> </ul>"},{"location":"pwn/ressources/#tools","title":"Tools","text":""},{"location":"pwn/ressources/#essentials","title":"Essentials","text":"<ul> <li>kali linux (recommended as VM)</li> <li>A disassembler &amp; decompiler of choice for static analysis<ul> <li>ghidra (free and pre-installed on kali)</li> <li>or others like binary ninja, IDA Free, radare2, ...</li> </ul> </li> <li>A debugger for dynamic analysis<ul> <li>gdb (free and pre-installed on kali)</li> <li>gef (enhanced gdb)</li> </ul> </li> <li>python &amp; pwntools</li> </ul>"},{"location":"pwn/ressources/#situational","title":"Situational","text":"<ul> <li>ropper: ROP Gadget Finder</li> <li>OneGadget: OneGadget Finder</li> </ul>"},{"location":"reverse-engineering/a-first-challenge/","title":"A first challenge","text":"<p>Let's get straight into an example challenge to showcase what the reverse engineering category is about.</p> <p>This challenge is called \"Who Wants to be a Millionaire: The Oracle's Whimsy\". The description says:</p> <p>In a future where reality has become unstable, an enigmatic entity known as The Oracle has grown bored with logic and created a game show where nothing makes sense. In Who Wants to be a Millionaire: The Oracle's Whimsy, contestants face absurd, gibberish questions with answers that defy reason, relying solely on luck to win unimaginable riches. Knowledge is obsolete, and the only way to succeed is by pleasing The Oracle through random guesses. Audiences are captivated by the sheer chaos and unpredictability, as players navigate a world where the only rule is that there are no rules. In this twisted game, wealth is determined not by wisdom, but by chance.</p> <p>DOWNLOAD: The challenge provides the file <code>the_oracles_whimsy</code> which can be downloaded here.</p>"},{"location":"reverse-engineering/a-first-challenge/#first-inspections","title":"First inspections","text":"<p>First thing we do is open the terminal and run the command <code>file</code> on <code>the_oracles_whimsy</code> to give some basic information about the file.</p> <pre><code>$ file the_oracles_whimsy\nthe_oracles_whimsy: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=cf4e3000306a57f52e6e3ba993722d58fb248121, for GNU/Linux 3.2.0, stripped\n</code></pre> <p>The output of the command tells us a lot of things. Most important are the following</p> <ul> <li>ELF: The file is an ELF file. ELF stands for Executable and Linkable Format and is a common standard file format for executable files, object code, shared libraries, and core dumps.</li> <li>64-bit: The program is compiled for 64-bit architecture. This means for example that the adresses have a length of 64-bit.</li> <li>LSB: LSB stands for Least Significant Byte and specifies the order of the bytes/ the endianness used.</li> <li>x86-64: this specifies the instruction set (assembly). Alternatives to x86-64 would be for example \"Intel 80386\" or \"ARM\".</li> <li>stripped: this means that symbols, like function names or global variables names have been deleted from the binary as some sort of obfuscation.</li> </ul>"},{"location":"reverse-engineering/a-first-challenge/#running-the-binary","title":"Running the binary","text":"<p>A word of caution: We do run this code, because we know that it is a harmless ctf challenge and is not going to do anything malicious to our machine. Do not run programs that you don't trust before inspecting it statically first. If you decide to run a program, always do so in a dedicated virtual machine and not on your host.</p> <p>To run the binary, we first have to adjust the files permission to make it executable by setting the \"executable bit\" with the command <code>chmod</code>.</p> <pre><code>$ chmod +x the_oracles_whimsy\n</code></pre> <p>Then, we are able to run it.</p> <pre><code>$ ./the_oracles_whimsy\nWelcome to: \n\n\u2554\u2566\u2557\u252c \u252c\u250c\u2500\u2510  \u2554\u2550\u2557\u252c\u2500\u2510\u250c\u2500\u2510\u250c\u2500\u2510\u252c  \u250c\u2500\u2510\u250c\u2500\u2510  \u2566 \u2566\u252c \u252c\u252c\u250c\u252c\u2510\u250c\u2500\u2510\u252c \u252c\n \u2551 \u251c\u2500\u2524\u251c\u2524   \u2551 \u2551\u251c\u252c\u2518\u251c\u2500\u2524\u2502  \u2502  \u251c\u2524 \u2514\u2500\u2510  \u2551\u2551\u2551\u251c\u2500\u2524\u2502\u2502\u2502\u2502\u2514\u2500\u2510\u2514\u252c\u2518\n \u2569 \u2534 \u2534\u2514\u2500\u2518  \u255a\u2550\u255d\u2534\u2514\u2500\u2534 \u2534\u2514\u2500\u2518\u2534\u2500\u2518\u2514\u2500\u2518\u2514\u2500\u2518  \u255a\u2569\u255d\u2534 \u2534\u2534\u2534 \u2534\u2514\u2500\u2518 \u2534 \n\n\nThe rules are: \n  1) All 15 questions are nonsensical and have no logical answers.\n  2) Answer the questions by writing 'A', 'B', 'C', or 'D'.\n  3) Win by guessing all 15 questions right.\n  4) Cryptic Price: The winner receives a mysterious reward!\n\nReady or not, the game starts now! Good luck! \n\n\n50\u20ac: What flavor does the wind have when it whispers secrets to the ocean?\nA: 3.14159265                    B: yikes\nC: Charlie Tango Foxtrot         D: Frog\n\nYour answer: \n</code></pre> <p>In this case it is, as expected, a kind of version like \"Who wants to be a millionaire\" but with nonsense questions and answers. When running the program a second time, we notice that the question and the answers change. To get this \"mysterious reward\" (the flag most probably), we would have to guess the right answer 15 times in a row. Chance of doing that is <code>0.25 ^ 15 = 0,000000000931323</code>, so we don't want to play this game the normal game.</p>"},{"location":"reverse-engineering/a-first-challenge/#how-to-cheat-the-game","title":"How to cheat the game","text":"<p>We want to find a way to cheat in the app. Take a minute to think about what you think would be possible to do. There are a lot of ways possible and I want to showcase some different ideas.</p> <p>A non-exhaustive list of ways/ideas to cheat</p> <ul> <li>decompile the app and try to find the flag inside the app</li> <li>run the app in a debugger. there you can change the values of registers manually and jump right to after the 15th question.</li> <li>run the app in a debugger and stop at every point, where your answer is compared to the \"right\" answer and flip the bit to true.</li> <li>patch the binary to jump to outputting the flag rigth away.</li> <li>the binary is probably using the \"rand\" function to choose the questions, answers and each right answer. override this random function with an own implementation that always returns the same value</li> </ul>"},{"location":"reverse-engineering/a-first-challenge/#decompiling-with-ghidra","title":"Decompiling with ghidra","text":"<p>When first opening ghidra, you have to create a new Project with <code>File &gt; New Project</code> from the menu bar, select \"Non-Shared Project\" and give it a name. After creating the new project, include the binary \"the_oracles_whimsy\" by clicking <code>File &gt; Import File...</code> and selecting the binary and clicking \"OK\" twice..</p> <p>Now, the binary shows up in the Tree View of the project. Double-click it or drag it on the dragon-icon. ghidra will ask, if you want to analyze the binary. Click \"Yes\" and \"Analyze\".</p> <p>As this binary is stripped, we first need to find the main function by hand. In the panel \"Symbol tree\" on the left, search for the \"entry\" function and select it.</p> <p>The following will show up in the decompilation pane on the right:</p> <pre><code>void processEntry entry(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined auStack_8 [8];\n\n  __libc_start_main(FUN_001012a2,param_2,&amp;stack0x00000008,0,0,param_1,auStack_8);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n</code></pre> <p>The first argument to <code>__libc_start_main</code> is always a pointer to the main function. Click on <code>FUN_001012a2</code> and press l to rename the function to \"main\". Now double-click <code>main</code> to jump to the decompiled main function.</p> <pre><code>undefined8 main(void)\n\n{\n  byte bVar1;\n  int iVar2;\n  time_t tVar3;\n  char local_32;\n  char local_31;\n  undefined *local_30;\n  undefined *local_28;\n  undefined *local_20;\n  undefined *local_18;\n  int local_c;\n\n  tVar3 = time((time_t *)0x0);\n  srand((uint)tVar3);\n  puts(\"Welcome to: \\n\");\n  puts(&amp;DAT_00103780);\n  puts(&amp;DAT_00103808);\n  puts(&amp;DAT_00103888);\n  puts(\"The rules are: \");\n  puts(\"  1) All 15 questions are nonsensical and have no logical answers.\");\n  puts(\"  2) Answer the questions by writing \\'A\\', \\'B\\', \\'C\\', or \\'D\\'.\");\n  puts(\"  3) Win by guessing all 15 questions right.\");\n  puts(\"  4) Cryptic Price: The winner receives a mysterious reward!\\n\");\n  puts(\"Ready or not, the game starts now! Good luck! \\n\\n\");\n  local_c = 0;\n  while( true ) {\n    if (0xe &lt; local_c) {\n      FUN_00101199();\n      return 0;\n    }\n    printf(&amp;DAT_00103a49,(ulong)*(uint *)(&amp;DAT_00103700 + (long)local_c * 4),\n           (&amp;PTR_s_What_flavor_does_the_wind_have_w_00106060)[local_c]);\n    iVar2 = rand();\n    local_18 = (&amp;PTR_s_Snergle_00106100)[(ulong)(long)iVar2 % 0x28];\n    iVar2 = rand();\n    local_20 = (&amp;PTR_s_Snergle_00106100)[(ulong)(long)iVar2 % 0x28];\n    iVar2 = rand();\n    local_28 = (&amp;PTR_s_Snergle_00106100)[(ulong)(long)iVar2 % 0x28];\n    iVar2 = rand();\n    local_30 = (&amp;PTR_s_Snergle_00106100)[(ulong)(long)iVar2 % 0x28];\n    iVar2 = rand();\n    bVar1 = (byte)(iVar2 &gt;&gt; 0x1f);\n    local_31 = (((char)iVar2 + (bVar1 &gt;&gt; 6) &amp; 3) - (bVar1 &gt;&gt; 6)) + 'A';\n    printf(\"A: %-22s\\t B: %s\\n\",local_18,local_20);\n    printf(\"C: %-22s\\t D: %s\\n\",local_28,local_30);\n    putchar(10);\n    printf(\"Your answer: \");\n    __isoc99_scanf(&amp;DAT_00103a84,&amp;local_32);\n    if (local_31 != local_32) break;\n    puts(\"Good job, that was the right answer! \");\n    local_c = local_c + 1;\n  }\n  printf(\"I\\'m sorry, that\\'s not correct. The answer the Oracle was looking for is \\'%c\\'. You lose !\\n\"\n         ,(ulong)(uint)(int)local_31);\n  return 0;\n}\n</code></pre> <p>This is the C Code of the main function that ghidra decompiled from the binary code. Now we can try to make sense of what exactly is happening. Decompiled code in ghidra always starts with the declaration of all the local variables in the function. The following two lines are: <pre><code>  tVar3 = time((time_t *)0x0);\n  srand((uint)tVar3);\n</code></pre> This sets up a pseudo-random number generator and seeds it with the current time. <code>srand</code> is an indication that later on, the <code>rand</code> function is being used to generate random values.</p> <p>Next, the rules are being printed to the console via the <code>puts</code> function.</p> <p>Then comes a <code>while(True)</code> Loop. Here it makes sense to look, how the program can break out of the loop and find the following: <pre><code>local_c = 0;\nwhile( true ) {\n  if (0xe &lt; local_c) {\n    FUN_00101199();\n    return 0;\n  }\n  ...\n  if (local_31 != local_32) break;\n  ...\n  local_c = local_c + 1;\n}\n</code></pre> We see the condition <code>if(0xe &lt; local_c)</code>. <code>0xe</code> represents the number 14 in hexadecimal number representation. You can rightclick on the number in ghidra to see the values in decimal, binary, octal and other representations. This means, if the variable <code>local_c</code>, that was initialised to 0 before the loop, is greater than 14, the function <code>FUN_00101199</code> is called and the main function ends with the <code>return 0;</code> statement. The variable <code>local_c</code> is incremented each iteration. If we think of the rules, we notice that there are 15 questions. So this <code>local_c</code> might represent the number of the current question. Let's rename the variable to <code>question_nbr</code> by hitting <code>l</code> on the keyboard.</p> <p>As an interesting side-note, the original program could also have looked like this: <pre><code>for (int i = 0; i &lt; 15; i++){\n  ...\n  if (local_31 != local_32) break;\n}\nFUN_00101199();\nreturn 0;\n</code></pre> This does exactly the same as the while loop from above and results in the same compiled binary code. Some decompilers might decompile it to a while loop, while other decompile it to a for loop. You can use dogbolt.org to see what different decompilers do. In our example, the Hex-Rays decompiler shows a for-loop, while ghidra and binaryninja both show a while-loop.</p> <p>Now, let's look into <code>FUN_00101199</code>, which is most probably the <code>win</code> or <code>getflag</code> function, whatever you would like to call it.</p> <pre><code>void FUN_00101199(void)\n\n{\n  undefined8 local_118;\n  undefined8 local_110;\n  undefined8 local_108;\n  undefined8 local_100;\n  undefined8 local_f8;\n  undefined8 local_f0;\n  undefined8 local_e8;\n  undefined8 local_e0;\n  undefined local_d8 [204];\n  int local_c;\n\n  local_e8 = 0x7766554433221100;\n  local_e0 = 0xffeeddccbbaa9988;\n  local_118 = 0xac1d60871fc5bd37;\n  local_110 = 0xa25f61a4f747edfd;\n  local_108 = 0x591d872197736fb7;\n  local_100 = 0x6c3550e8e7a13305;\n  local_f8 = 0x2035325aab697d40;\n  local_f0 = 0x68dd201dde4edda4;\n  FUN_00101832(local_d8,&amp;local_e8);\n  for (local_c = 0; local_c &lt; 3; local_c = local_c + 1) {\n    FUN_0010270c(local_d8,(long)&amp;local_118 + (long)(local_c &lt;&lt; 4));\n  }\n  printf(\"Congrats, you win! Here is your mystery rewards: \");\n  puts((char *)&amp;local_118);\n  return;\n}\n</code></pre> <p>We see: At the bottom, there is a message printed \"Congrats, you win! Here is your mystery rewards:\" and the value at pointer <code>local_118</code>, that is the flag. We also see that this value is \"calculated\" beforehand using other functions <code>FUN_00101832</code> and <code>FUN_0010270c</code>. At this point, we kinda don't want to spend more time looking at this code statically and trying to make sense of more stuff.</p> <p>In the outgoing calls we even see, that a lot more nested functions are being called. </p> <p>So let's jump into our Dynamic Analysis!</p>"},{"location":"reverse-engineering/a-first-challenge/#dynamic-analysis-with-gdbgef","title":"Dynamic analysis with gdb+gef","text":"<p>Make sure to have gdb and gef (GDB enhanced features) installed.</p> <pre><code>gdb the_oracles_whimsy\n</code></pre>"},{"location":"reverse-engineering/introduction/","title":"Introduction","text":""},{"location":"reverse-engineering/introduction/#what-to-expect","title":"What to expect","text":"<p>The majority of the challenges are programs written in C and compiled for x64 architecture linux machines. This means that the player is provided an ELF file. With the help of a tool called disassembler, the file can be translated from machine code into assembly language. A tool called decompiler can then try to translate the assembly back into  high-level source code like C code. The player then tries to make sense of the source code to find out what the program is doing exactly. Oftentimes, the player has to dig into the assembly code generated by the disassembler, because decompilers often make mistakes or fail to decompile parts of the code.</p> <p>Other types of challenges include Android Apps (apk format) that are written in Java or Kotlin.</p>"},{"location":"reverse-engineering/introduction/#skills-required-or-motivation-to-learn","title":"Skills required (or Motivation to learn)","text":"<ul> <li>C (understanding code, not necessarily writing)</li> <li>assembly (understanding, not writing)</li> </ul>"},{"location":"reverse-engineering/introduction/#types-of-challenges-not-an-exhaustive-list","title":"Types of challenges (not an exhaustive list)","text":"<ul> <li>reverse engineering crypto implementation</li> <li>reverse engineering a game</li> <li>reverse engineering a program acting as a virtual machine with its own instruction set</li> <li>reverse engineering an android app</li> <li>reverse engineering a flag-checker</li> <li>bypassing obfuscation and anti-reversing measures</li> </ul>"},{"location":"reverse-engineering/introduction/#if-you-have-questions","title":"If you have questions...","text":"<p>...feel free to ask people on Discord in the LCSC Server or me directly (#mathisfoxius)</p>"},{"location":"reverse-engineering/ressources/","title":"Ressources","text":""},{"location":"reverse-engineering/ressources/#educational","title":"Educational","text":""},{"location":"reverse-engineering/ressources/#learning-platforms","title":"Learning platforms","text":"<ul> <li>pwn.college: Great and free Cybersecurity courses in general and they have a reverse engineering dojo</li> <li>hextree.io: Great for learning about Android Security, also has some general Reverse Engineering content</li> <li>Azeria Labs: Great for learning ARM assembly</li> </ul>"},{"location":"reverse-engineering/ressources/#other","title":"Other","text":"<ul> <li>\"Self-Learning Reverse Engineering in 2022\" by LiveOverflow: YT Video</li> <li>Practical Binary Analysis by Dennis Andriesse: Great book (nostarchpress has a lot of great cybersecurity books)</li> </ul>"},{"location":"reverse-engineering/ressources/#tools","title":"Tools","text":""},{"location":"reverse-engineering/ressources/#essentials","title":"Essentials","text":"<ul> <li>kali linux (recommended as VM)</li> <li>A disassembler &amp; decompiler of choice for static analysis<ul> <li>ghidra (free and pre-installed on kali)</li> <li>or others like binary ninja, IDA Free, radare2, ...</li> </ul> </li> <li>A debugger for dynamic analysis<ul> <li>gdb (free and pre-installed on kali)</li> <li>gef (enhanced gdb)</li> </ul> </li> <li>python &amp; pwntools</li> <li>Note-taking app</li> </ul>"},{"location":"reverse-engineering/ressources/#situational","title":"Situational","text":"<ul> <li>A hex editor<ul> <li>imhex (free)</li> <li>or others like 010editor</li> </ul> </li> <li>angr (symbolic execution)</li> <li>z3 (SMT solver)</li> <li>Android Studio, jadx &amp; frida (for reversing android apps)</li> <li>PE-bear (for reversing Windows PE binaries)</li> <li>qemu &amp; gdb-multiarch (for reversing ARM binaries on x64 machines)</li> <li>CheatEngine (for Windows game hacking)</li> </ul>"},{"location":"web-security/introduction/","title":"Introduction","text":""},{"location":"web-security/introduction/#what-to-expect","title":"What to expect","text":"<p>In the web security category, the challenges are about exploiting vulnerabilities inside web applications. Principally, we distinguish between 2 goals a web challenge can have:</p> <ul> <li>Server-Side: Attack and compromise the server, that the web application is running on.  Here, the flag is usually hidden inside a file on the server. </li> <li>Client-Side: Attack an admin user (an admin bot in our setup) through the web application and exfiltrate sensitive information. Here, the flag is usually hidden inside a cookie of the admin-bot.</li> </ul> <p>A non-exhaustive list of some common vulnerabilities/techniques one might encounter in web challenges:</p> <ul> <li>SQL Injection [SQLi] (Server-side)</li> <li>Local File Inclusion (Server-side)</li> <li>Race conditions (Server-side)</li> <li>Server-Side Template Injection (Server-Side)</li> <li>Cross-Site Scripting [XSS] (Client-side)</li> <li>Cross-Site Request Forgery [CORF] (Client-side)</li> <li>Cross-Origin Ressource Sharing [CORS] (Client-side)</li> <li>Client-Side Template Injection [CSTI] (Client-side)</li> </ul>"},{"location":"web-security/introduction/#skills-required-or-motivation-to-learn","title":"Skills required (or Motivation to learn)","text":"<ul> <li>Using a proxy (like Burpsuite) to intercept, view and modify HTTP Packages your browser sends and receives.</li> <li>Being able to read and understand HTML &amp; JavaScript</li> <li>Knowing and recognize vulnerabilities</li> <li>Using <code>docker-compose</code> to build and run the challenges locally.</li> </ul>"},{"location":"web-security/introduction/#if-you-have-questions","title":"If you have questions...","text":"<p>...feel free to ask people on Discord in the LCSC Server or me directly (#mathisfoxius)</p>"},{"location":"web-security/ressources/","title":"Ressources","text":""},{"location":"web-security/ressources/#educational","title":"Educational","text":""},{"location":"web-security/ressources/#learning-platforms","title":"Learning platforms","text":"<ul> <li>Portswigger Academy: Covers the most important concepts/techniques/vulnerabilites in a beginner-friendly way and has labs to practice. From the developers of Burp Suite (Industry Standard)</li> <li>Beyond XSS: Blog, that covers Client-Side vulnerabilities/attacks.</li> <li>PicoCTF Learning Guide</li> </ul>"},{"location":"web-security/ressources/#beginner-challenges","title":"Beginner challenges","text":"<ul> <li>PicoCTF</li> </ul>"},{"location":"web-security/ressources/#tools","title":"Tools","text":""},{"location":"web-security/ressources/#essentials","title":"Essentials","text":"<ul> <li>A browser</li> <li>Burp Suite: A proxy to intercept, view and modify HTTP Packages your browser sends and receives.</li> <li>A code editor to view provided source code</li> <li>Docker and docker-compose to run the challenges locally with ease.</li> </ul>"},{"location":"web-security/ressources/#situational","title":"Situational","text":"<ul> <li>webhook.site to have a site, that the admin-bot can send the flag to.</li> <li>Python requests to code an automized solution in python.</li> <li>PayloadsAllTheThings: A collection of useful payloads for different vulnerabilities.</li> </ul>"}]}